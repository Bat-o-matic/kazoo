####### Pre-Processor Directives #########
#!define L_ALERT -5
#!define L_BUG -4
#!define L_CRIT2 -3
#!define L_CRIT -2
#!define L_ERR -1
#!define L_WARN 0
#!define L_NOTICE 1
#!define L_INFO 2
#!define L_DBG 3

#!define AVP_RECV_PARAM "recv_param"
#!define AVP_LOG_LEVEL "log_level"
#!define AVP_ROUTE_CNT "route_cnt"
#!define AVP_ASSOCIATED_SERVER "associated_server"
#!define AVP_ASSOCIATE_CONTACT "associate_contact"

####### Global Parameters #########
fork = yes
children = 25
#group =
#user =
server_signature = no
server_header = "Server: 2600hz"
user_agent_header = "User-Agent: 2600hz"
shm_force_alloc = yes
mlock_pages = yes
phone2tel = 1
max_while_loops = 500

####### Logging Parameters #########
debug = L_INFO
memdbg = L_DBG
memlog = L_DBG
corelog = L_ERR
log_stderror = no
log_facility = LOG_LOCAL0
log_name="kamailio"

####### Alias Parameters #########
auto_aliases = yes
alias = "mydomain.net"

####### Binding Parameters #########
listen = tcp:XXX.XXX.XXX.XXX:5060
listen = udp:XXX.XXX.XXX.XXX:5060
listen = tcp:XXX.XXX.XXX.XXX:5080
listen = udp:XXX.XXX.XXX.XXX:5080
listen = tcp:XXX.XXX.XXX.XXX:7000
listen = udp:XXX.XXX.XXX.XXX:7000
tos = IPTOS_LOWDELAY

####### TCP Parameters #########
tcp_children = 25
disable_tcp = no
tcp_max_connections = 4096
tcp_connection_lifetime = 3605
tcp_accept_aliases = no
tcp_async = yes
tcp_connect_timeout = 10
tcp_conn_wq_max = 65536
tcp_crlf_ping = yes
tcp_delayed_ack = yes
tcp_fd_cache = yes
tcp_keepalive = yes
tcp_keepcnt = 3
tcp_keepidle = 30
tcp_keepintvl = 10
tcp_linger2 = 30
tcp_rd_buf_size = 4096
tcp_send_timeout = 10
tcp_wq_blk_size = 2100
tcp_wq_max = 10485760

####### UDP Parameters #########
udp4_raw = -1
udp4_raw_mtu = 1500

####### DNS Parameters #########
dns = no
rev_dns = no
dns_try_ipv6 = no
use_dns_cache = on
dns_cache_del_nonexp = no
dns_cache_flags = 1
dns_cache_gc_interval = 120
dns_cache_init = 1
dns_cache_mem = 1000
dns_cache_negative_ttl = 60
dns_try_naptr = no
use_dns_failover = off
dns_srv_lb = off

####### TLS Parameters #########
enable_tls = yes

####### SCTP Parameters #########
disable_sctp = yes

####### Custom Parameters #########


####### Modules Section ########
mpath="/opt/kamailio/lib64/kamailio/modules_k/:/opt/kamailio/lib64/kamailio/modules/"

######## Kamailio core extensions module ########
loadmodule "kex.so"

######## Transaction (stateful) module ########
loadmodule "tm.so"
loadmodule "tmx.so"
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Attempting to connect your call")
modparam("tm", "cancel_b_method", 2)
modparam("tm", "ruri_matching", 0)
modparam("tm", "failure_reply_mode", 3)
# modparam("tm", "fr_timer", 30000)
# modparam("tm", "fr_inv_timer", 120000)

######## Stateless replier module ########
loadmodule "sl.so"

######## Record-Route and Route module ########
loadmodule "rr.so"
modparam("rr", "enable_full_lr", 1)

######## Max-Forward processor module ########
loadmodule "maxfwd.so"

######## SIP utilities [requires sl] ########
loadmodule "siputils.so"

######## SIP message formatting sanity checks [requires sl] ########
loadmodule "sanity.so"
# sip_version, scheme, req_headers, cseq_method/value
# content_length, parse_uri, digest
modparam("sanity", "default_checks", 3303)
modparam("sanity", "uri_checks", 3)
modparam("sanity", "autodrop", 0)

######## Text operations module ########
loadmodule "textops.so"

######## NAT traversal module - signaling functions ########
loadmodule "nathelper.so"
modparam("nathelper", "received_avp", "$avp(AVP_RECV_PARAM)")

######## Path support for SIP loadbalancer ########
loadmodule "path.so"
modparam("path", "use_received", 0)

######## Generic Hash Table container in shared memory ########
loadmodule "htable.so"
modparam("htable", "htable", "associations=>size=14;")

######## Memcached connector module ########
loadmodule "memcached.so"
modparam("memcached", "servers", "localhost:11211")
modparam("memcached", "expire", 10800)
modparam("memcached", "mode", 0)
modparam("memcached", "timeout", 10000)

######## Module holding Pseudo-Variables ########
loadmodule "pv.so"

######## Advanced logger module ########
loadmodule "xlog.so"

####### FIFO support for Management Interface  ########
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_fifo")

####### Different config utilities  ########
loadmodule "cfgutils.so"

####### Flags #######
flags
    FLAG_INTERNALLY_SOURCED:  1,
    FLAG_ITSP_SOURCED:        2,
    FLAG_ASSOCIATE_SERVER:    3,
    FLAG_SKIP_NAT_CORRECTION: 4;

####### Routing Logic ########
route {
    # log the basic info regarding this call
    xlog("L_INFO", "$ci|start|recieved $oP request $rm $ou");
    xlog("L_INFO", "$ci|log|source $si:$sp");
    xlog("L_INFO", "$ci|log|from $fu");
    xlog("L_INFO", "$ci|log|to $tu");

    route(SANITY_CHECK);

    route(SET_LOGGING_FLAGS);

    route(CLASSIFY_SOURCE);

    route(HANDLE_OPTIONS);

    route(HANDLE_IN_DIALOG_REQUESTS);

    route(PREPARE_INITIAL_REQUESTS);

    if (isflagset(FLAG_INTERNALLY_SOURCED)) {
        route(INTERNAL_TO_EXTERNAL_RELAY);
        exit();
    }

    route(FIND_ROUTES);

    route(HANDLE_MOVE_REQUEST);

    route(EXTERNAL_TO_INTERNAL_RELAY);
}

route[SANITY_CHECK] {
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_WARN", "$ci|end|max-forward limit reached");
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (msg:len >= 2048) {
        xlog("L_WARN", "$ci|end|message length exceeds 2048");
        sl_send_reply("513", "Message too big");
        exit;
    }

    if (!sanity_check()) {
        xlog("L_WARN", "$ci|end|message is insane");
        exit;
    }
}

route[SET_LOGGING_FLAGS] {
    return();
}

route[CLASSIFY_SOURCE] {
    switch($mct($si)) {
        case "itsp":
            xlog("L_INFO", "$ci|log|message is from ITSP");
            setflag(FLAG_ITSP_SOURCED);
        break;
        case "kazoo":
            xlog("L_INFO", "$ci|log|message is from KAZOO");
            setflag(FLAG_INTERNALLY_SOURCED);
        break;
        case "vcc":
            xlog("L_INFO", "$ci|log|message is from VCC");
            setflag(FLAG_INTERNALLY_SOURCED);
        break;
        default:
            xlog("L_INFO", "$ci|log|message is from an unknown source");
        break;
    }
}

route[HANDLE_OPTIONS] {
    if (is_method("OPTIONS")) {
        if (isflagset(FLAG_INTERNALLY_SOURCED)) {
            record_route();
            route(INTERNAL_TO_EXTERNAL_RELAY);
        } else {
            sl_send_reply("503", "Rawr!!");
        }
        exit;
    }
}

route[HANDLE_IN_DIALOG_REQUESTS] {
    if (has_totag()) {
        if (loose_route()) {
            route(RELAY);
        } else if (t_check_trans()) {
            xlog("L_INFO", "$ci|log|allow message for a known transaction");
            route(RELAY);
        } else if (isflagset(FLAG_INTERNALLY_SOURCED)) {
            xlog("L_INFO", "$ci|log|relay internally sourced in-dialog message without loose_route");
            route(RELAY);
        } else {
            xlog("L_INFO", "$ci|log|message had a to-tag but can't be loose routed");
            sl_send_reply("481", "Call Leg/Transaction Does Not Exist");
        }
        exit();
    }
}

route[PREPARE_INITIAL_REQUESTS] {
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        } else {
            sl_send_reply("481", "Call Leg/Transaction Does Not Exist");
        }
        exit();
    } else if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit();
    }

    t_check_trans();

    if (loose_route()) {
        sl_send_reply("403", "No pre-loaded routes");
        exit();
    }

    if (is_method("REGISTER")) {
        if (!add_path_received()) {
            sl_send_reply("503", "Internal path befuddlement");
            route(CLEANUP_DIALOG);
            exit();
        }
    } else {
        record_route();
    }
}

route[MAYBE_ASSOCIATE_SERVER] {
    if (isflagset(FLAG_ASSOCIATE_SERVER) && defined $avp(AVP_ASSOCIATED_SERVER)) {
        xlog("L_INFO", "$ci|log|associate call-id $ci with $avp(AVP_ASSOCIATED_SERVER)");
        $sht(associations=>$ci) = $avp(AVP_ASSOCIATED_SERVER);

        if (is_method("INVITE")) {
            $var(user) = $(ct{tobody.user}) + "@" + $si;
            xlog("L_INFO", "$ci|log|associate user $var(user) with $avp(AVP_ASSOCIATED_SERVER)");
            $sht(associations=>$var(user)) = $avp(AVP_ASSOCIATED_SERVER);
        }
    }
}

route[FIND_ROUTES] {
    if (!route(LOAD_DNIS_ROUTES) && !route(LOAD_KAZOO_ROUTES)) {
        xlog("L_INFO", "$ci|log|no routes available");
        send_reply("404", "Not Found");
        exit;
    }

    if (defined $sht(associations=>$ci)) {
        $var(prefered_route) = $sht(associations=>$ci);
        xlog("L_INFO", "$ci|log|should route to $var(prefered_route)");
    }

#    route(LOG_ROUTES);

    route(NEXT_ROUTE);
}

route[LOAD_DNIS_ROUTES] {
    ## TODO: normalize the number
    if (isflagset(FLAG_ITSP_SOURCED) && $rU =~ "^[0-9\.\+\-]+") {
        $var(routes) = $mct($rU);
        route(LOAD_ROUTES);
    } else {
        return(-1);
    }
}

route[LOAD_VCC_ROUTES] {
    $var(routes) = $mct(available_vcc_routes);
    route(LOAD_ROUTES);
}

route[LOAD_KAZOO_ROUTES] {
    $var(routes) = $mct(available_kazoo_routes);
    route(LOAD_ROUTES);

    $var(randomizer_pos) = $avp(AVP_ROUTE_CNT);
    route(RANDOMIZE_ROUTES);

    if (!isflagset(FLAG_ITSP_SOURCED) && is_method("REGISTER|INVITE|SUBSCRIBE")) {
        setflag(FLAG_ASSOCIATE_SERVER);
    }
}

route[LOAD_ROUTES] {
    if ($var(routes) == $null) {
        return(-1);
    }

    $var(i) = 0;
    $var(route) = $(var(routes){s.select,$var(i),;});
    while($(var(route){s.len}) > 0) {
        $var(i) = $var(i) + 1;
        $avp($var(i)) = $var(route);
        $var(route) = $(var(routes){s.select,$var(i),;});
    }
    $avp(AVP_ROUTE_CNT) = $var(i);

    return(1);
}

route[NEXT_ROUTE] {
    if ($avp(AVP_ROUTE_CNT) <= 0) {
        return(-1);
    }

    $var(domain) = $(avp($avp(AVP_ROUTE_CNT)){uri.host});
    $var(port) = $(avp($avp(AVP_ROUTE_CNT)){uri.port});

    $avp(AVP_ROUTE_CNT) = $avp(AVP_ROUTE_CNT) - 1;

    if ($(var(domain){s.len}) <= 0) {
        route(NEXT_ROUTE);
    }

    if ($(var(port){s.len}) <= 4) {
        $var(port) = "5060";
    }

    $du = "sip:" + $var(domain) + ":" + $var(port);

    return(1);
}

route[RANDOMIZE_ROUTES] {
    if ($var(randomizer_pos) <= 0) {
        return();
    }

    $var(random_pos) = ($RANDOM mod $var(randomizer_pos) + 1);

    if ($var(random_pos) != $var(randomizer_pos)) {
        $var(route) = $avp($var(randomizer_pos));
        $avp($var(randomizer_pos)) = $avp($var(random_pos));
        $avp($var(random_pos)) = $var(route);
    }

    $var(randomizer_pos) = $var(randomizer_pos) - 1;
    route(RANDOMIZE_ROUTES);
}

route[HANDLE_MOVE_REQUEST] {
    return();
}

route[RELAY] {
    if (is_method("CANCEL") || is_method("BYE")) {
        route(CLEANUP_DIALOG);
    }

    if (isflagset(FLAG_INTERNALLY_SOURCED)) {
        route(INTERNAL_TO_EXTERNAL_RELAY);
    } else {
        route(EXTERNAL_TO_INTERNAL_RELAY);
    }

    exit();
}

route[INTERNAL_TO_EXTERNAL_RELAY] {
    remove_hf("X-AUTH-IP");

    t_on_reply("EXTERNAL_REPLY");

    t_set_fr(0, 10000);

    route(LOG_DESTINATION);

    t_relay();
}

route[EXTERNAL_TO_INTERNAL_RELAY] {
    if (!isflagset(FLAG_ITSP_SOURCED)) {
        route(NAT_TEST_AND_CORRECT);
    }

    remove_hf("X-AUTH-IP");
    append_hf("X-AUTH-IP: $si\r\n");

    t_on_reply("INTERNAL_REPLY");
    t_on_failure("INTERNAL_FAULT");

    t_set_fr(0, 1000);

    route(LOG_DESTINATION);

    $avp(AVP_ASSOCIATED_SERVER) = "sip:" + $var(domain) + ":" + $var(port);

    t_relay();
}

route[CLEANUP_DIALOG] {
    xlog("L_INFO", "$ci|log|remove any association for $ci");
    sht_rm_name_re("associations=>$ci");
    return();
}

route[LOG_ROUTES] {
    $var(i) = $avp(AVP_ROUTE_CNT);
    while($var(i) > 0) {
        $var(value) = $avp($var(i));
        xlog("L_INFO", "$ci|log|route $var(i): $var(value)");
        $var(i) = $var(i) - 1;
    }
}

route[LOG_DESTINATION] {
    if (isdsturiset()) {
        $var(port) = $dp;
        $var(domain) = $dd;
    } else {
        $var(port) = $rp;
        $var(domain) = $rd;
    }

    if ($(var(port){s.len}) <= 0) {
        $var(port) = "5060";
    }

    xlog("L_INFO", "$ci|pass|$var(domain):$var(port)");
}

route[NAT_TEST_AND_CORRECT] {
    if (is_present_hf("Record-Route")) {
        $var(i) = $rr_count;
        while($var(i) > 0) {
            $var(i) = $var(i) - 1;
            $var(rr) = $(hdr(Record-Route)[$var(i)]);
            if (!is_myself("$(var(rr){nameaddr.uri})")) {
                setflag(FLAG_SKIP_NAT_CORRECTION);
            }
        }
    } else if ($Rp == "5080") {
        setflag(FLAG_SKIP_NAT_CORRECTION);
    }

    if (isflagset(FLAG_SKIP_NAT_CORRECTION)) {
        return();
    }

    if (nat_uac_test("3")) {
        force_rport();
        fix_nated_contact();
    }

    if (has_body("application/sdp") && nat_uac_test("8")) {
        fix_nated_sdp("10");
    }
}

onreply_route[EXTERNAL_REPLY] {
    xlog("L_INFO", "$ci|log|external reply $T_reply_code");
    route(NAT_TEST_AND_CORRECT);

    if (is_method("INVITE") && t_check_status("200")) {
        $var(user) = $(ct{tobody.user}) + "@" + $(ct{tobody.host});
        xlog("L_INFO", "$ci|log|associate user $var(user) with $avp(AVP_ASSOCIATED_SERVER)");
    #    $sht(associations=>$var(user)) = $avp(AVP_ASSOCIATED_SERVER);
    }
}

onreply_route[INTERNAL_REPLY] {
    xlog("L_INFO", "$ci|log|internal reply $T_reply_code");
    if (is_method("SUBSCRIBE") && t_check_status("202|201")) {
        route(MAYBE_ASSOCIATE_SERVER);
    }
}

failure_route[INTERNAL_FAULT]
{
    if (is_method("CANCEL") || is_method("BYE")) {
        route(CLEANUP_DIALOG);
    } else if (t_check_status("401|407")) {
        route(MAYBE_ASSOCIATE_SERVER);
        return();
    } else if (t_check_status("403")) {
        xlog("L_INFO", "$ci|log|failure route overriding reply code 403 with 503");
        send_reply("503", "Error: Services Unavailable. Try Later");
        exit();
    } else if (t_check_status("402")) {
        xlog("L_INFO", "$ci|log|failure route overriding reply code 402 with 486");
        send_reply("486", "Insufficient Funds");
        exit();
    } else if (t_check_status("(4[0-9][0-9])|(5[0-9][0-9])") && route(NEXT_ROUTE)) {
        route(EXTERNAL_TO_INTERNAL_RELAY);
        exit();
    } else {
        xlog("L_ERR", "$ci|log|no other media servers avaliable");
    }

    route(LOG_DESTINATION);
}

## vim:set tabstop=4 softtabstop=4 shiftwidth=4 expandtab
